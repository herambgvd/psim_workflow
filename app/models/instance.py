"""
Enterprise State Machine Workflow Engine - Instance Models

This module defines models for workflow instances and their execution history.
Workflow instances represent actual executions of workflow definitions.
"""

import enum
from datetime import datetime
from typing import Any, Dict, List, Optional
from sqlalchemy import (
    Column,
    String,
    Text,
    JSON,
    Integer,
    Boolean,
    DateTime,
    ForeignKey,
    Enum as SQLEnum,
    Index,
    CheckConstraint
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship, validates
from sqlalchemy.sql import func

from app.models.base import BaseModel


class InstanceStatus(enum.Enum):
    """Enumeration of workflow instance statuses."""
    CREATED = "created"  # Instance created but not started
    RUNNING = "running"  # Instance is currently executing
    WAITING = "waiting"  # Waiting for external input/event
    PAUSED = "paused"  # Manually paused execution
    COMPLETED = "completed"  # Successfully completed
    FAILED = "failed"  # Failed with error
    CANCELLED = "cancelled"  # Cancelled by user
    TIMEOUT = "timeout"  # Execution timed out
    TERMINATED = "terminated"  # Forcefully terminated


class Priority(enum.Enum):
    """Enumeration of execution priorities."""
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    CRITICAL = "critical"


class WorkflowInstance(BaseModel):
    """
    Model for workflow instances.

    Represents an actual execution of a workflow definition with
    its own state, data, and execution history.
    """

    __tablename__ = "workflow_instances"

    # Reference to workflow definition
    workflow_definition_id = Column(
        UUID(as_uuid=True),
        ForeignKey("workflow_definitions.id"),
        nullable=False,
        index=True,
        doc="ID of the workflow definition this instance is based on"
    )

    # Instance identification
    name = Column(
        String(255),
        nullable=True,
        index=True,
        doc="Optional human-readable name for this instance"
    )

    description = Column(
        Text,
        nullable=True,
        doc="Optional description of this specific instance"
    )

    # Execution status and control
    status = Column(
        SQLEnum(InstanceStatus),
        nullable=False,
        default=InstanceStatus.CREATED,
        index=True,
        doc="Current status of the workflow instance"
    )

    priority = Column(
        SQLEnum(Priority),
        nullable=False,
        default=Priority.NORMAL,
        index=True,
        doc="Execution priority of this instance"
    )

    # Timing information
    scheduled_at = Column(
        DateTime(timezone=True),
        nullable=True,
        index=True,
        doc="When the instance is scheduled to start"
    )

    started_at = Column(
        DateTime(timezone=True),
        nullable=True,
        index=True,
        doc="When the instance actually started execution"
    )

    completed_at = Column(
        DateTime(timezone=True),
        nullable=True,
        index=True,
        doc="When the instance completed execution"
    )

    last_activity_at = Column(
        DateTime(timezone=True),
        nullable=True,
        index=True,
        doc="Timestamp of last activity in this instance"
    )

    # Timeout and retry configuration
    timeout_at = Column(
        DateTime(timezone=True),
        nullable=True,
        index=True,
        doc="When the instance will timeout"
    )

    max_retries = Column(
        Integer,
        nullable=False,
        default=3,
        doc="Maximum number of retries for this instance"
    )

    retry_count = Column(
        Integer,
        nullable=False,
        default=0,
        doc="Current number of retry attempts"
    )

    # Input and output data
    input_data = Column(
        JSON,
        nullable=True,
        doc="Input data provided when starting the instance"
    )

    output_data = Column(
        JSON,
        nullable=True,
        doc="Output data generated by the workflow execution"
    )

    # Context and variables
    context_data = Column(
        JSON,
        nullable=True,
        default=dict,
        doc="Runtime context and variables for the instance"
    )

    # Error handling
    error_message = Column(
        Text,
        nullable=True,
        doc="Error message if the instance failed"
    )

    error_details = Column(
        JSON,
        nullable=True,
        doc="Detailed error information and stack traces"
    )

    # Execution metadata
    tags = Column(
        JSON,
        nullable=True,
        default=list,
        doc="Tags for categorizing and searching instances"
    )

    metadata = Column(
        JSON,
        nullable=True,
        default=dict,
        doc="Additional metadata for the instance"
    )

    # Parent-child relationships for sub-workflows
    parent_instance_id = Column(
        UUID(as_uuid=True),
        ForeignKey("workflow_instances.id"),
        nullable=True,
        index=True,
        doc="ID of parent instance if this is a sub-workflow"
    )

    # External references
    external_id = Column(
        String(255),
        nullable=True,
        index=True,
        doc="External system identifier for this instance"
    )

    correlation_id = Column(
        String(255),
        nullable=True,
        index=True,
        doc="Correlation ID for tracking across systems"
    )

    # Metrics and statistics
    step_count = Column(
        Integer,
        nullable=False,
        default=0,
        doc="Number of steps/transitions executed"
    )

    duration_seconds = Column(
        Integer,
        nullable=True,
        doc="Total execution duration in seconds"
    )

    # Relationships
    workflow_definition = relationship(
        "WorkflowDefinition",
        back_populates="instances"
    )

    execution_context = relationship(
        "ExecutionContext",
        back_populates="workflow_instance",
        uselist=False,
        cascade="all, delete-orphan"
    )

    execution_history = relationship(
        "ExecutionHistory",
        back_populates="workflow_instance",
        cascade="all, delete-orphan",
        order_by="ExecutionHistory.created_at"
    )

    parent_instance = relationship(
        "WorkflowInstance",
        remote_side="WorkflowInstance.id",
        back_populates="child_instances"
    )

    child_instances = relationship(
        "WorkflowInstance",
        back_populates="parent_instance"
    )

    # Constraints and indexes
    __table_args__ = (
        CheckConstraint('retry_count <= max_retries', name='ck_retry_count_limit'),
        Index('ix_instance_status_priority', 'status', 'priority'),
        Index('ix_instance_scheduled', 'scheduled_at', postgresql_where=status == InstanceStatus.CREATED),
        Index('ix_instance_running', 'status', postgresql_where=status == InstanceStatus.RUNNING),
        Index('ix_instance_external', 'external_id'),
        Index('ix_instance_correlation', 'correlation_id'),
        Index('ix_instance_tags', 'tags', postgresql_using='gin'),
    )

    @validates('priority')
    def validate_priority(self, key: str, priority: Priority) -> Priority:
        """Validate instance priority."""
        if not isinstance(priority, Priority):
            try:
                priority = Priority(priority)
            except ValueError:
                raise ValueError(f"Invalid priority: {priority}")
        return priority

    def start_execution(self, input_data: Optional[Dict] = None) -> None:
        """Start workflow instance execution."""
        if self.status != InstanceStatus.CREATED:
            raise ValueError(f"Cannot start instance in status: {self.status}")

        self.status = InstanceStatus.RUNNING
        self.started_at = datetime.utcnow()
        self.last_activity_at = datetime.utcnow()

        if input_data:
            self.input_data = input_data

        # Initialize context data if not present
        if not self.context_data:
            self.context_data = {}

    def pause_execution(self) -> None:
        """Pause workflow instance execution."""
        if self.status != InstanceStatus.RUNNING:
            raise ValueError(f"Cannot pause instance in status: {self.status}")

        self.status = InstanceStatus.PAUSED
        self.last_activity_at = datetime.utcnow()

    def resume_execution(self) -> None:
        """Resume paused workflow instance execution."""
        if self.status != InstanceStatus.PAUSED:
            raise ValueError(f"Cannot resume instance in status: {self.status}")

        self.status = InstanceStatus.RUNNING
        self.last_activity_at = datetime.utcnow()

    def complete_execution(self, output_data: Optional[Dict] = None) -> None:
        """Complete workflow instance execution."""
        if self.status not in (InstanceStatus.RUNNING, InstanceStatus.WAITING):
            raise ValueError(f"Cannot complete instance in status: {self.status}")

        self.status = InstanceStatus.COMPLETED
        self.completed_at = datetime.utcnow()
        self.last_activity_at = datetime.utcnow()

        if output_data:
            self.output_data = output_data

        self._calculate_duration()

    def fail_execution(self, error_message: str, error_details: Optional[Dict] = None) -> None:
        """Mark workflow instance as failed."""
        self.status = InstanceStatus.FAILED
        self.error_message = error_message
        self.error_details = error_details
        self.completed_at = datetime.utcnow()
        self.last_activity_at = datetime.utcnow()

        self._calculate_duration()

    def cancel_execution(self) -> None:
        """Cancel workflow instance execution."""
        if self.status in (InstanceStatus.COMPLETED, InstanceStatus.FAILED):
            raise ValueError(f"Cannot cancel instance in status: {self.status}")

        self.status = InstanceStatus.CANCELLED
        self.completed_at = datetime.utcnow()
        self.last_activity_at = datetime.utcnow()

        self._calculate_duration()

    def timeout_execution(self) -> None:
        """Mark workflow instance as timed out."""
        self.status = InstanceStatus.TIMEOUT
        self.completed_at = datetime.utcnow()
        self.last_activity_at = datetime.utcnow()

        self._calculate_duration()

    def increment_retry_count(self) -> None:
        """Increment retry count."""
        if self.retry_count >= self.max_retries:
            raise ValueError("Maximum retries exceeded")

        self.retry_count += 1
        self.last_activity_at = datetime.utcnow()

    def increment_step_count(self) -> None:
        """Increment step count."""
        self.step_count += 1
        self.last_activity_at = datetime.utcnow()

    def set_context_variable(self, key: str, value: Any) -> None:
        """Set a context variable."""
        if not self.context_data:
            self.context_data = {}
        self.context_data[key] = value
        self.last_activity_at = datetime.utcnow()

    def get_context_variable(self, key: str, default: Any = None) -> Any:
        """Get a context variable value."""
        if not self.context_data:
            return default
        return self.context_data.get(key, default)

    def _calculate_duration(self) -> None:
        """Calculate execution duration."""
        if self.started_at and self.completed_at:
            delta = self.completed_at - self.started_at
            self.duration_seconds = int(delta.total_seconds())

    @property
    def is_running(self) -> bool:
        """Check if instance is currently running."""
        return self.status == InstanceStatus.RUNNING

    @property
    def is_completed(self) -> bool:
        """Check if instance has completed (success or failure)."""
        return self.status in (
            InstanceStatus.COMPLETED,
            InstanceStatus.FAILED,
            InstanceStatus.CANCELLED,
            InstanceStatus.TIMEOUT,
            InstanceStatus.TERMINATED
        )

    @property
    def is_successful(self) -> bool:
        """Check if instance completed successfully."""
        return self.status == InstanceStatus.COMPLETED

    @property
    def execution_time(self) -> Optional[float]:
        """Get current execution time in seconds."""
        if not self.started_at:
            return None

        end_time = self.completed_at or datetime.utcnow()
        return (end_time - self.started_at).total_seconds()

    @property
    def can_retry(self) -> bool:
        """Check if instance can be retried."""
        return (
                self.status == InstanceStatus.FAILED and
                self.retry_count < self.max_retries
        )


class HistoryEventType(enum.Enum):
    """Enumeration of execution history event types."""
    INSTANCE_CREATED = "instance_created"
    INSTANCE_STARTED = "instance_started"
    INSTANCE_PAUSED = "instance_paused"
    INSTANCE_RESUMED = "instance_resumed"
    INSTANCE_COMPLETED = "instance_completed"
    INSTANCE_FAILED = "instance_failed"
    INSTANCE_CANCELLED = "instance_cancelled"
    INSTANCE_TIMEOUT = "instance_timeout"
    STATE_ENTERED = "state_entered"
    STATE_EXITED = "state_exited"
    TRANSITION_EXECUTED = "transition_executed"
    TASK_STARTED = "task_started"
    TASK_COMPLETED = "task_completed"
    TASK_FAILED = "task_failed"
    EVENT_RECEIVED = "event_received"
    EVENT_PROCESSED = "event_processed"
    ERROR_OCCURRED = "error_occurred"
    RETRY_ATTEMPTED = "retry_attempted"
    VARIABLE_SET = "variable_set"
    CHECKPOINT_CREATED = "checkpoint_created"


class ExecutionHistory(BaseModel):
    """
    Model for tracking workflow instance execution history.

    Maintains a detailed log of all events and state changes
    during workflow execution for auditing and debugging.
    """

    __tablename__ = "execution_history"

    # Reference to workflow instance
    workflow_instance_id = Column(
        UUID(as_uuid=True),
        ForeignKey("workflow_instances.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        doc="ID of the workflow instance this history entry belongs to"
    )

    # Event information
    event_type = Column(
        SQLEnum(HistoryEventType),
        nullable=False,
        index=True,
        doc="Type of event that occurred"
    )

    event_name = Column(
        String(255),
        nullable=True,
        index=True,
        doc="Name of the specific event or action"
    )

    description = Column(
        Text,
        nullable=True,
        doc="Human-readable description of the event"
    )

    # State information
    from_state = Column(
        String(255),
        nullable=True,
        index=True,
        doc="State before the event (for transitions)"
    )

    to_state = Column(
        String(255),
        nullable=True,
        index=True,
        doc="State after the event (for transitions)"
    )

    # Event data
    event_data = Column(
        JSON,
        nullable=True,
        doc="Additional data associated with the event"
    )

    # Timing
    event_timestamp = Column(
        DateTime(timezone=True),
        nullable=False,
        server_default=func.now(),
        index=True,
        doc="When the event occurred"
    )

    duration_ms = Column(
        Integer,
        nullable=True,
        doc="Duration of the event in milliseconds"
    )

    # Actor information
    actor_type = Column(
        String(50),
        nullable=True,
        doc="Type of actor that triggered the event (user, system, external)"
    )

    actor_id = Column(
        String(255),
        nullable=True,
        doc="ID of the actor that triggered the event"
    )

    # Context
    execution_context = Column(
        JSON,
        nullable=True,
        doc="Execution context at the time of the event"
    )

    # Error information (if applicable)
    error_message = Column(
        Text,
        nullable=True,
        doc="Error message if the event was an error"
    )

    error_details = Column(
        JSON,
        nullable=True,
        doc="Detailed error information"
    )

    # Sequence and ordering
    sequence_number = Column(
        Integer,
        nullable=False,
        doc="Sequence number for ordering events within an instance"
    )

    # Relationships
    workflow_instance = relationship(
        "WorkflowInstance",
        back_populates="execution_history"
    )

    # Indexes for performance
    __table_args__ = (
        Index('ix_history_instance_sequence', 'workflow_instance_id', 'sequence_number'),
        Index('ix_history_timestamp', 'event_timestamp'),
        Index('ix_history_event_type', 'event_type'),
        Index('ix_history_states', 'from_state', 'to_state'),
    )

    @validates('event_type')
    def validate_event_type(self, key: str, event_type: HistoryEventType) -> HistoryEventType:
        """Validate event type."""
        if not isinstance(event_type, HistoryEventType):
            try:
                event_type = HistoryEventType(event_type)
            except ValueError:
                raise ValueError(f"Invalid event type: {event_type}")
        return event_type

    def is_state_transition(self) -> bool:
        """Check if this event represents a state transition."""
        return self.event_type == HistoryEventType.TRANSITION_EXECUTED

    def is_error_event(self) -> bool:
        """Check if this event represents an error."""
        return self.event_type in (
            HistoryEventType.INSTANCE_FAILED,
            HistoryEventType.TASK_FAILED,
            HistoryEventType.ERROR_OCCURRED
        )

    def is_completion_event(self) -> bool:
        """Check if this event represents completion."""
        return self.event_type in (
            HistoryEventType.INSTANCE_COMPLETED,
            HistoryEventType.TASK_COMPLETED
        )


# Add relationships to WorkflowDefinition for instances
def add_instance_relationships():
    """Add instance relationships to WorkflowDefinition model."""
    from app.models.workflow import WorkflowDefinition

    WorkflowDefinition.instances = relationship(
        "WorkflowInstance",
        back_populates="workflow_definition",
        cascade="all, delete-orphan",
        lazy="dynamic"
    )


# Call this function to establish relationships
add_instance_relationships()